
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>【JavaScript】ES6-Generator函数 | Hi,I am Sirius!</title>
<meta name="description" content="Learn faster, catch up with the technology iteration earlier！">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://SiriusZHT.github.io/favicon.ico?v=1611124586276">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://SiriusZHT.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://SiriusZHT.github.io">
        <img class="avatar" src="https://SiriusZHT.github.io/images/avatar.png?v=1611124586276" alt="" width="32px" height="32px">
      </a>
      <a href="https://SiriusZHT.github.io">
        <h1 class="site-title">Hi,I am Sirius!</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="https://SiriusZHT.github.io/post/ge-ren-zhi-zuo-de-yi-xie-kai-yuan-xiao-xiang-mu" class="menu purple-link">
            项目
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://SiriusZHT.github.io/post-images/javascript-es6-generator-han-shu.jpeg')">
            </div>
          
          <h2 class="post-title">【JavaScript】ES6-Generator函数</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-01-16</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://SiriusZHT.github.io/tag/6b8sklbLZ/">
                    es6
                    
                      ，
                    
                  </a>
                
                  <a href="https://SiriusZHT.github.io/tag/v9lIiSyUe/">
                    JavaScript
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h2 id="一-什么是generator-函数">一、什么是Generator 函数</h2>
<h3 id="11-语法">1.1 语法</h3>
<blockquote>
<p>学习 <code>Generator</code> 语法，你需要了解<code>function*</code> 、<code>yield</code>、<code>next</code>三个基本概念。</p>
</blockquote>
<ul>
<li><code>function*</code> 用来声明一个函数是生成器函数，它比普通的函数声明多了一个<code>*</code>,<code>*</code>的位置比较随意可以挨着 <code>function</code> 关键字，也可以挨着函数名</li>
<li><code>yield</code> 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有<code>yield</code> 关键字，函数遇到 <code>yield</code> 的时候会暂停，并把 <code>yield</code> 后面的表达式结果抛出去</li>
<li><code>next</code>作用是将代码的控制权交还给生成器函数</li>
</ul>
<pre><code class="language-js">// 声明生成器函数
function* generator() {
    // A
    yield 'foo'
    // B
}
// 获取生成器对象
let g = generator();
// 第一个 next()，首次启动生成器
g.next(); // {value: &quot;foo&quot;, done: false}
// 唤醒被 yield 暂停的状态
g.next();
// {value: undefined, done: true}
</code></pre>
<h3 id="12-过程分析">1.2 过程分析</h3>
<pre><code class="language-js">// 分析一个简单例子
function* helloGenerator() {
   yield &quot;hello&quot;;
   yield &quot;generator&quot;;
   return;
}

var h = helloGenerator();

console.log(h.next());//{ value: 'hello', done: false }
console.log(h.next());//{ value: 'generator', done: false }
console.log(h.next());//{ value: 'undefined', done: true }
</code></pre>
<ul>
<li>创建了<code>h</code>对象，指向<code>helloGenerator</code>的句柄</li>
<li>第一次调用<code>next()</code>，执行到<code>&quot;yield hello&quot;</code>，暂缓执行,并返回了<code>&quot;hello&quot;</code></li>
<li>第二次调用<code>next()</code>，继续上一次的执行，执行到<code>&quot;yield generator&quot;</code>,暂缓执行，并返回了<code>&quot;generator&quot;</code>。</li>
<li>第三次调用<code>next()</code>,直接执行<code>return</code>，并返回<code>done:true</code>，表明结束</li>
</ul>
<blockquote>
<p>经过上面的分析，<code>yield</code>实际就是暂缓执行的标示，每执行一次<code>next()</code>，相当于指针移动到下一个<code>yield</code>位置</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/img_convert/b353767950ca17c65dd80f7ce78c6651.png" alt="" loading="lazy"></figure>
<p><strong>总结一下</strong>，<code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p>
<h3 id="13-yield-表达式">1.3 yield 表达式</h3>
<blockquote>
<p><code>yield</code>是<code>Generator</code>函数的暂缓执行的标识，对于<code>yield</code>只能配合<code>Generator</code>函数使用，在普通的函数中使用会报错</p>
</blockquote>
<p><code>Generator</code>函数中还有一种<code>yield*</code>这个表达方式</p>
<pre><code class="language-js">function* foo(){
   	yield &quot;a&quot;;
   	yield &quot;b&quot;;
   }
   function* gen(x,y){
   	  yield 1;
   	  yield 2;
   	  yield* foo();
   	  yield 3;
   }
   var g = gen();
   console.log(g.next());//{value: 1, done: false}
   console.log(g.next());//{value: 2, done: false}
   console.log(g.next());//{value: &quot;a&quot;, done: true}
   console.log(g.next());//{value: &quot;b&quot;, done: true}
   console.log(g.next());//{value: &quot;3&quot;, done: true
}
</code></pre>
<blockquote>
<p>当执行<code>yield*</code>时，实际是遍历后面的<code>Generator</code>函数，等价于下面的写法：</p>
</blockquote>
<pre><code class="language-js">
function* foo(){
   	yield &quot;a&quot;;
   	yield &quot;b&quot;;
}
function* gen(x,y){
    yield 1;
    yield 2;
    
    for(var value of foo()){
      yield value;
    }
    
    yield 3;
}
</code></pre>
<p><strong>注意</strong>：<code>yield</code> 后面只能适配<code>Generator</code>函数</p>
<h2 id="二-generator应用场景">二、Generator应用场景</h2>
<h3 id="21-异步操作的同步化表达">2.1 异步操作的同步化表达</h3>
<blockquote>
<p><code>Generator</code>函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，<code>Generator</code>函数的一个重要实际意义就是用来处理异步操作，改写回调函数</p>
</blockquote>
<pre><code class="language-js">function* loadUI() {
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
}
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<blockquote>
<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰</p>
</blockquote>
<ul>
<li>通过<code>Generator</code>函数部署<code>Ajax</code>操作，可以用同步的方式表达。</li>
</ul>
<pre><code class="language-js">function* main() {
  var result = yield request(&quot;http://some.url&quot;);
  var resp = JSON.parse(result);
    console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}

var it = main();
it.next();
</code></pre>
<h3 id="22-控制流管理">2.2 控制流管理</h3>
<pre><code class="language-js">// 异步函数

function getDataAsync (url) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            var res = {
                url: url,
                data: Math.random()
            }
            resolve(res)
        }, 1000)
    })
}
</code></pre>
<blockquote>
<p>使用 <code>Generator</code> 函数可以这样写</p>
</blockquote>
<pre><code class="language-js">function * getData () {
    var res1 = yield getDataAsync('/page/1?param=123')
    console.log(res1)
    var res2 = yield getDataAsync(`/page/2?param=${res1.data}`)
    console.log(res2)
    var res3 = yield getDataAsync(`/page/2?param=${res2.data}`)
    console.log(res3))
}
</code></pre>
<blockquote>
<p>然后我们这样逐步执行</p>
</blockquote>
<pre><code class="language-js">var g = getData()
g.next().value.then(res1 =&gt; {
    g.next(res1).value.then(res2 =&gt; {
        g.next(res2).value.then(() =&gt; {
            g.next()
        })
    })
})
</code></pre>
<blockquote>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code>方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code>方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p>
</blockquote>
<pre><code class="language-js">function run (gen) {
    var g = gen()

    function next (data) {
        var res = g.next(data)
        if (res.done) return res.value
        res.value.then((data) =&gt; {
            next(data)
        })
    }
    next()
}
</code></pre>
<blockquote>
<p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 <code>getData</code> 方法</p>
</blockquote>
<pre><code>run(getData)
</code></pre>
<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code>方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code>是 <code>Generator</code>函数处理异步的语法糖了</p>
</blockquote>
<h3 id="23-部署-iterator-接口">2.3 部署 Iterator 接口</h3>
<blockquote>
<p>利用 <code>Generator</code> 函数，可以在任意对象上部署 <code>Iterator</code> 接口。</p>
</blockquote>
<pre><code class="language-js">function* iterEntries(obj) {
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}

let myObj = { foo: 3, bar: 7 };

for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}

// foo 3
// bar 7
</code></pre>
<blockquote>
<p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 <code>Iterator</code> 接口。也就是说，可以在任意对象上部署<code>next</code>方法</p>
</blockquote>
<pre><code class="language-js">// 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口

function* makeSimpleGenerator(array){
  var nextIndex = 0;

  while(nextIndex &lt; array.length){
    yield array[nextIndex++];
  }
}

var gen = makeSimpleGenerator(['yo', 'ya']);

gen.next().value // 'yo'
gen.next().value // 'ya'
gen.next().done  // true
</code></pre>
<h2 id="三-更多参考">三、更多参考</h2>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/generator">ryf教程-generator</a></li>
<li>FE- interview</li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://SiriusZHT.github.io/post/javascript-dom-bian-cheng-xue-xi-zong-jie-pian/">
              <h3 class="post-title">
                下一篇：【JavaScript】DOM编程学习总结篇
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">Learn faster, catch up with the technology iteration earlier！</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/SiriusZHT" target="_blank">SiriusZHT</a> | <a class="rss" href="https://SiriusZHT.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0e2b7616ef50e5477f63',
        clientSecret: '4f4531fcaf20c0c748d00ca4f35a0e2cf3672090',
        repo: 'SiriusZHT.github.io',
        owner: 'SiriusZHT',
        admin: ['SiriusZHT'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>

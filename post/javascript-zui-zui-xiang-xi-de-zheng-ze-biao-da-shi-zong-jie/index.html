
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>【JavaScript】最最详细的正则表达式总结 | Hi,I am Sirius!</title>
<meta name="description" content="Learn faster, catch up with the technology iteration earlier！">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://SiriusZHT.github.io/favicon.ico?v=1611124586276">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://SiriusZHT.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://SiriusZHT.github.io">
        <img class="avatar" src="https://SiriusZHT.github.io/images/avatar.png?v=1611124586276" alt="" width="32px" height="32px">
      </a>
      <a href="https://SiriusZHT.github.io">
        <h1 class="site-title">Hi,I am Sirius!</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="https://SiriusZHT.github.io/post/ge-ren-zhi-zuo-de-yi-xie-kai-yuan-xiao-xiang-mu" class="menu purple-link">
            项目
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://SiriusZHT.github.io/post-images/javascript-zui-zui-xiang-xi-de-zheng-ze-biao-da-shi-zong-jie.jpeg')">
            </div>
          
          <h2 class="post-title">【JavaScript】最最详细的正则表达式总结</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-01-14</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://SiriusZHT.github.io/tag/v9lIiSyUe/">
                    JavaScript
                    
                      ，
                    
                  </a>
                
                  <a href="https://SiriusZHT.github.io/tag/XAd4hx7kCO/">
                    正则表达式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <ul>
<li>之前在刷leetcode的时候发现有很多问题都是通过正则表达式来解决的，所以有必要在对其进行总结，本文参考<a href="https://www.cnblogs.com/wenruo/p/10612437.html">这篇文章</a><br>
那么我们开始吧<br>
<ul class="markdownIt-TOC">
<li><a href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">创建正则表达式</a>
<ul>
<li><a href="#1%E7%9B%B4%E6%8E%A5%E9%87%8F%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA">1.直接量语法创建</a></li>
<li><a href="#2%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA">2.对象构造函数创建</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E9%87%8F%E5%AD%97%E7%AC%A6">直接量字符</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%B1%BB">字符类</a></li>
<li><a href="#%E9%87%8D%E5%A4%8D">重复</a>
<ul>
<li><a href="#%E8%B4%AA%E5%A9%AA%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA%E7%9A%84%E9%87%8D%E5%A4%8D">贪婪和非贪婪的重复</a></li>
</ul>
</li>
<li><a href="#%E9%80%89%E6%8B%A9-%E5%88%86%E7%BB%84%E5%92%8C%E5%BC%95%E7%94%A8">选择、分组和引用</a>
<ul>
<li><a href="#%E9%80%89%E6%8B%A9">选择</a></li>
<li><a href="#%E5%88%86%E7%BB%84">分组</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a>
<ul>
<li><a href="#%E5%85%B7%E5%90%8D%E5%BC%95%E7%94%A8">具名引用</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E5%BC%95%E7%94%A8">忽略引用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%E9%94%9A%E5%85%83%E7%B4%A0">指定匹配位置（锚元素）</a>
<ul>
<li><a href="#%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">先行断言</a></li>
<li><a href="#%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li>
<li><a href="#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">后行断言</a></li>
<li><a href="#%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%90%8E%E9%9D%A2%E7%9A%84%E9%80%89%E6%8B%A9%E9%A1%B9">修饰符（/后面的选择项）</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95">正则表达式对象的原型方法</a>
<ul>
<li><a href="#stringprototypesearchregexpsubstr">String.prototype.search(regexp|substr)</a></li>
<li><a href="#stringprototypereplaceregexpsubstr-newsubstrfunction">String.prototype.replace(regexp|substr, newSubStr|function)</a></li>
<li><a href="#stringprototypematchregexp">String.prototype.match(regexp)</a></li>
<li><a href="#stringprototypesplitseparator-limit">String.prototype.split([separator[, limit]])</a></li>
</ul>
</li>
<li><a href="#regexp-%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7">RegExp 的原型属性</a></li>
<li><a href="#regexp-%E7%9A%84%E6%96%B9%E6%B3%95">RegExp 的方法</a>
<ul>
<li><a href="#exec">exec()</a></li>
<li><a href="#test">test()</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用的正则表达式</a></li>
</ul>
</li>
</ul>
<h1 id="创建正则表达式">创建正则表达式</h1>
<blockquote>
<p>正则表达式用RegExp对象表示</p>
</blockquote>
<h2 id="1直接量语法创建">1.直接量语法创建</h2>
<ul>
<li>就是我们经常看到的斜杠 “/”</li>
</ul>
<h2 id="2对象构造函数创建">2.对象构造函数创建</h2>
<pre><code class="language-js">new RegExp(pattern[,flags])
RegExp(pattern[,flags])
</code></pre>
<ul>
<li>pattern可以是字符串或者正则字面量，字符串的时候要用常规的字符转义规则，必须将<code>\</code>替换成<code>\\</code><br>
比如：<code>/\w+/</code>等价为<code>new RegExp(&quot;\\w+&quot;)</code></li>
</ul>
<h1 id="直接量字符">直接量字符</h1>
<p>在正则表达式中，有一些标点符号具有特殊含义，他们是<code>：^ $ . * + ? = ! : | \ / ( ) [ ] { }</code> 如果需要在正则表达式中与这些直接量进行匹配，必须使用前缀 <code>\</code>。<code>没有“-”号</code></p>
<h1 id="字符类">字符类</h1>
<p>通过将直接量字符放入方括号内，可以组成字符类（character class）。一个字符类可以匹配它所包含任意 一个 字符。如 <code>[abc] 可以匹配 a，b，c 中任意一个字符</code>。注意！！！<strong>是任意一个</strong></p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201208102959733.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>方括号内也可出现转义字符，如 [\d\s] 表示匹配任意空白符或数字。</li>
</ul>
<h1 id="重复">重复</h1>
<blockquote>
<p>当一个模式需要被多次循环匹配的时候，正则表达式提供了表示重复的正则语法。<br>
<img src="https://img-blog.csdnimg.cn/20201208103136971.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<h2 id="贪婪和非贪婪的重复">贪婪和非贪婪的重复</h2>
<p>上面所有的重复都是“贪婪的”匹配，也就是匹配尽可能多的字符。如 <code>/a+/ 匹配 'aaaa'</code> 时，它会匹配 <code>'aaaa'</code></p>
<p>注意：正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置，这意味这 <code>/a+?b/ 匹配 'aaab'</code> 时，匹配到的是 <code>'aaab' 而不是 'ab'</code>。</p>
<h1 id="选择-分组和引用">选择、分组和引用</h1>
<h2 id="选择">选择</h2>
<p>字符 | 用于分隔供选择的模式，匹配时会尝试从左到右匹配每一个分组，直到发现匹配项。如 <code>/ab|bc|cd/ 可以匹配字符串'ab'、'bc' 和 'cd'。</code></p>
<h2 id="分组">分组</h2>
<p>圆括号可以把单独的项组合成子表达式，以便可以像一个独立的单元用 <code>|、*、+ 或者 ?</code> 对单元内的项进行处理。</p>
<h2 id="引用">引用</h2>
<p>带圆括号的表达式的另一个用途是允许在同一个正则表达式的后面<strong>引用前面的子表达式</strong>。通过\后面加数字实现。\n 表示第 n 个带圆括号的子表达式。表示引用前一个表达式所匹配的文本。因为子表达式可以嵌套，所以根据子表达式左括号的位置进行计数。</p>
<ul>
<li>例，能匹配 1999-01-01 或 1999/01/01 的正则：<code>/\d{4}([-\/])\d{2}\1\d{2}/</code><br>
这里<code>\1</code>对第一个出现的括号子表达式进行了引用</li>
</ul>
<h3 id="具名引用">具名引用</h3>
<p>使用 <code>(?&lt;name&gt;...)</code> 的语法来为分组命名，并通过 <code>\k&lt;name&gt;</code> 在后面的正则表达式中引用。</p>
<ul>
<li>如例，能匹配 1999-01-01 或 1999/01/01 的正则：<code>/\d{4}(?&lt;separator&gt;[-\/])\d{2}\k&lt;separator&gt;\d{2}/</code></li>
</ul>
<h3 id="忽略引用">忽略引用</h3>
<p>如果只想用圆括号来表示子表达式，而不希望生成引用，可以使用 (?😃 来进行分组。例，<code>/(?:a)(?:b)(c)/ 中 \1 将表示 (c) 所匹配的文本</code>。</p>
<h1 id="指定匹配位置锚元素">指定匹配位置（锚元素）</h1>
<p>正则表达式中的锚字符包括：</p>
<ul>
<li>^ 用来匹配字符串的开始，多行检索时匹配一行的开头。</li>
<li>$ 用来匹配字符串的结束，多行检索时匹配一行的结尾。</li>
<li>\b 用来匹配单词的边界，就是 \w 和 \W 之间的位置，或者 \w 和字符串的开头或结尾之间的位置。</li>
<li>\B 匹配非单词边界的位置。</li>
</ul>
<p>例： <code>/\bJava\b/ 可以匹配 Java 却不匹配 JavaScript。</code></p>
<p>任意正则表达式都可以作为锚点条件。</p>
<h2 id="先行断言">先行断言</h2>
<p>(?=pattern)<br>
如 <code>/\d+(?=%)/</code> 匹配字符串 <code>'100%'</code> 中的 <code>'100'</code> 但是不匹配 <code>'100。'</code></p>
<h2 id="负向先行断言">负向先行断言</h2>
<p>反向匹配</p>
<h2 id="后行断言">后行断言</h2>
<p>(?&lt;=pattern)<br>
如<code>/(?&lt;=\$)\d+/</code> 匹配 <code>'$100'</code> 但是不匹配 <code>'￥100'</code></p>
<h2 id="负向后行断言">负向后行断言</h2>
<h1 id="修饰符后面的选择项">修饰符（/后面的选择项）</h1>
<ul>
<li>i 执行不区分大小写的匹配。</li>
<li>g 全局匹配。</li>
<li>m 多行匹配模式。</li>
<li>y “粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而<code>y修饰符确保匹配必须从剩余的第一个位置开始</code>，这也就是“粘连”的涵义。</li>
<li>s 表示点（.）可以表示任意字符，不设置的话，四个字节的 UTF-16 字符和行终止符不能用 . 表示。</li>
<li>u 开启 “Unicode 模式”，用来正确处理大于 \uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</li>
</ul>
<p>通过 <code>RegExp.prototype.flags</code> 可以获得正则修饰符的字符串。<code>/pattern/ig.flags 返回 &quot;gi&quot;</code></p>
<h1 id="正则表达式对象的原型方法">正则表达式对象的原型方法</h1>
<h2 id="stringprototypesearchregexpsubstr">String.prototype.search(regexp|substr)</h2>
<p>返回第一个和参数匹配的子串的起始位置。没有匹配子串返回 -1 。</p>
<p>如果参数不是正则表达式，将会通过 RegExp 构造函数转换成正则表达式。它会忽略正则的修饰符 g。</p>
<h2 id="stringprototypereplaceregexpsubstr-newsubstrfunction">String.prototype.replace(regexp|substr, newSubStr|function)</h2>
<p>第一个参数同search，查找指定子串。如果第二个表达式是字符串，将把第一个参数匹配的子串替换为 newSubStr。如果在替换字符串中出现了 $ 加数字，replace 将用与指定的子表达式相匹配的文本来替换这些字符。</p>
<p>例，单书名号包裹文本改为书名号。<code>'&lt;JavaScript&gt;和&lt;正则表达式&gt;'.replace(/&lt;([^_]*?)&gt;/g, '《$1》') 会得到 &quot;《JavaScript》和《正则表达式》&quot;</code></p>
<p>使用字符串作为参数时替换字符串可以插入下面的特殊变量名：</p>
<ul>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 8:  插入一个 &quot;$̲&quot;
'> 插入一个 &quot;$&quot;
</p>
</li>
<li>`$`` 插入当前匹配的子串左边的内容。</li>
<li>$' 插入当前匹配的子串右边的内容。</li>
<li>$n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始</li>
</ul>
<p>使用函数作为第二个参数</p>
<pre><code class="language-js">function replacer(match, p1, p2, p3, offset, string) { }
// match        匹配的子串。
// p1,p2, ...   假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。
// offset       匹配到的子字符串在原字符串中的偏移量。子串首字母下标。
// string       被匹配的原字符串。
</code></pre>
<p>例，下划线命名转驼峰命名。<code>'a_simple_name'.replace(/_([a-z])/g, (m, p1) =&gt; p1.toUpperCase()) 将得到 &quot;aSimpleName&quot;。</code></p>
<h2 id="stringprototypematchregexp">String.prototype.match(regexp)</h2>
<p>参数 regexp 为一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。</p>
<p>如果 regexp 没有设置修饰符 g，则仅返回第一个完整匹配及其相关的捕获组（Array），返回数组第一个字符是匹配字符串，余下的元素是正则表达式中圆括号括起来的子表达式。在这种情况下，返回的项目将具有如下所述的其他属性（groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。index: 匹配的结果的开始位置。input: 搜索的字符串。），或者未匹配时返回 null 。</p>
<p>如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组，或者未匹配时返回 null 。</p>
<pre><code class="language-js">'196.168.0.1'.match(/(\d+)(?=.|$)/) // (?=.|$) 先行匹配 匹配 . 或者字符串结尾
// (2) [&quot;196&quot;, &quot;196&quot;, index: 0, input: &quot;196.168.0.1&quot;, groups: undefined]
'196.168.0.1'.match(/(?&lt;num&gt;\d+)(?=.|$)/) // (?&lt;name&gt;) 具名引用 见上文
// (2) [&quot;196&quot;, &quot;196&quot;, index: 0, input: &quot;196.168.0.1&quot;, groups: {num: &quot;196&quot;}]
'196.168.0.1'.match(/\d+(?=.|$)/g)
// (4) [&quot;196&quot;, &quot;168&quot;, &quot;0&quot;, &quot;1&quot;]
</code></pre>
<h2 id="stringprototypesplitseparator-limit">String.prototype.split([separator[, limit]])</h2>
<p>separator 指定表示每个拆分应发生的点的字符串，可以是一个字符串或正则表达式。如果空字符串（&quot;&quot;）被用作分隔符，则字符串会在每个字符之间分割。</p>
<p>limit 一个整数，限定返回的分割片段数量。</p>
<p>例，<code>'张三;李四,王五|赵六'.split(/[;\|,]/) // (4) [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;]</code></p>
<h1 id="regexp-的原型属性">RegExp 的原型属性</h1>
<ul>
<li>flags 会返回正则表达式的修饰符。</li>
<li>表示对应修饰符是否存在的只读布尔值，global(表示是否带有修饰符 g)，ignoreCase （i），multiline（m），sticky（y），dotAll（s），unicode（u）</li>
<li>source 只读字符串，包含正则表达式的文本。</li>
<li>lastIndex 可读/写整数。如果带有 g 修饰符，这个属性存储在整个字符串中下一次检索的开始位置。这个属性会被 exec() 和 test() 方法用到。</li>
</ul>
<h1 id="regexp-的方法">RegExp 的方法</h1>
<h2 id="exec">exec()</h2>
<p>如果没有找到任何属性，将返回 null，如果找到匹配返回一个数组，该数组第一个元素是相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。</p>
<p>当调用 exec() 的正则表达式具有修饰符 g 时，它将把当前正则表达式对象的 lastIndex 属性设置为紧挨着匹配子串的字符位置。</p>
<p>注意即使两次匹配的不是同一个字符串，lastIndex 还是会连续生效的。</p>
<pre><code class="language-js">let reg = /\d+/g;
reg.exec('25*10=250'); // [&quot;25&quot;, index: 0, input: &quot;25*10=250&quot;, groups: undefined]
reg.lastIndex; // 2
reg.exec('666'); // [&quot;6&quot;, index: 2, input: &quot;666&quot;, groups: undefined]
reg.lastIndex; // 3
</code></pre>
<h2 id="test">test()</h2>
<p>调用 test() 和 exec() 等价，当 exec() 返回结果不是 null，test() 返回 true，否则返回 false 。</p>
<p>String 的方法不会用到 lastIndex 属性。</p>
<h1 id="常用的正则表达式">常用的正则表达式</h1>
<pre><code class="language-js">//（1）匹配 16 进制颜色值
var color = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;

//（2）匹配日期，如 yyyy-mm-dd 格式
var date = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

//（3）匹配 qq 号
var qq = /^[1-9][0-9]{4,10}$/g;

//（4）手机号码正则
var phone = /^1[34578]\d{9}$/g;

//（5）用户名正则
var username = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;

//（6）Email正则
var email = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;

//（7）身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

//（8）URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

// (9)ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

// (10)//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;

// (11)强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：
var pwd = /^(?=.\d)(?=.[a-z])(?=.[A-Z]).{8,10}$/
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://SiriusZHT.github.io/post/pythonwangluobianchengqimofuxi/">
              <h3 class="post-title">
                下一篇：【Python网络编程】期末复习
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">Learn faster, catch up with the technology iteration earlier！</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/SiriusZHT" target="_blank">SiriusZHT</a> | <a class="rss" href="https://SiriusZHT.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0e2b7616ef50e5477f63',
        clientSecret: '4f4531fcaf20c0c748d00ca4f35a0e2cf3672090',
        repo: 'SiriusZHT.github.io',
        owner: 'SiriusZHT',
        admin: ['SiriusZHT'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
